#!/usr/bin/env rune

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def makeURIKit := <import:org.quasiliteral.syntax.URIKit>
def DEBuilderOf := <elib:serial.DEBuilderOf>
def deENodeKit := <elib:serial.deENodeKit>
def makePrettyFeeder := <elang:syntax.PrettyFeeder>
def EParser := <elang:syntax.EParser>

/**
 * Prints a Kernel-E AST with some syntactic shorthands restored.
 * <p>
 * This is currently used only for printing the output of uneval, so it
 * currently handles the AST cases generated by uneval, but few if any others.
 *
 * @author Mark S. Miller
 */
def deSrcKit {

    to makeBuilder() :near {
        deSrcKit.makeBuilder(79, 1)
    }

    to makeBuilder(wrapColumn :int, sugarLevel :int) :near {

        # The index of the next temp variable
        var nextTemp := 0

        def deSrcBuilder implements DEBuilderOf(String, String) {

            to getNodeType() :near { String }
            to getRootType() :near { String }

            to buildRoot(root :String) :String {
                def result := makePrettyFeeder.pretty(root)
                # Remove terminal newline
                def last := result.size() -1
                if (last >= 0 && result[last] == '\n') {
                    result(0,last)
                } else {
                    result
                }
            }

            to buildLiteral(value) :String {
                if (value =~ i :int && i.bitLength() > 120) {
                    def quot64 := i.toString64().quote()
                    `__makeInt.fromString64($quot64)`
                } else {
                    E.toQuote(value)
                }
            }

            to buildImport(varName :String) :String { varName }
            to buildIbid(tempIndex :int)    :String { `t_$tempIndex` }

            to buildCall(var rec :String,
                         verb :String,
                         args :String[]) :String {
                if (rec =~ `def t_@_`) {
                    # the result would otherwise misparse.
                    rec := `($rec)`
                }
                var argList := ", ".rjoin(args)
                if (rec.size() + argList.size() > wrapColumn - 20) {
                    argList := ",\n".rjoin(args)
                }
                if (args.size() >= 1 &&
                      rec.size() + args[0].size() > wrapColumn - 20) {

                    argList := "\n" + argList + "\n"
                }

                if (sugarLevel <= 0) {
                    return `$rec.$verb($argList)`
                }

                switch ([rec, verb, args]) {
                    match [`@{protocol}__uriGetter`, `get`, [`"@body"`]] ?
                      (makeURIKit.isURICs(body) && ! body.contains('\\')) {

                        `<$protocol:$body>`
                    }
                    match [`@{protocol}__uriGetter`, `get`, [arg0]] {
                        `<$protocol: $arg0>`
                    }
                    match [`__makeList`, `run`, _] {
                        `[$argList]`
                    }
                    match [_, `run`, _] {
                        `$rec($argList)`
                    }
                    match [_, `negate`, []] {
                        `-$rec`
                    }
                    match _ {
                        `$rec.$verb($argList)`
                    }
                }
            }

            to buildDefine(rValue :String) :[String, int] {
                def tempIndex := nextTemp
                nextTemp += 1
                [`def t_$tempIndex := $rValue`, tempIndex]
            }

            to buildPromise() :int {
                def promIndex := nextTemp
                nextTemp += 2
                promIndex
            }

            to buildDefrec(resIndex :int, rValue :String) :String {
                def promIndex := resIndex -1
                `def t_$promIndex := $rValue`
            }
        }
    }

    to recognize(src :String, builder) :(builder.getRootType()) {
        var ast := EParser(src)
        # repair circular definition form
        deENodeKit.recognize(ast, builder)
    }
}
